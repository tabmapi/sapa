import numpy as np
import pandas as pd
import re
import os
import shutil as sh
import glob
import time
import difflib as dl
import h5py
from zipfile import ZipFile

# the class which can contain any cif file
# IMPORTANT - the cif file must have a line at the end starting with a # symbol
# This is included by default in cifs generated by ISODISTORT
# This is NOT included by default in cifs generated by TOPAS
class sapa:
    """A class used to generate and execute symmetry-adapted PDF analysis (SAPA) input files for TOPAS

    ...

    Arguments
    ----------
    cif_file : The sapa class takes an ISODISTORT-generated cif as it's only input. The filename is required to be a string
    and must have a line designating the end of the file (e.g. #End)

    sample : A sample name used for reference. It is used in output file names. Format - string

    cycles : The number of convergences to be performed for each irreducible representation (irrep). Format - string

    path : The path to the directory containing the data files. Do not include any filename in this argument. Use double
           slashes e.g. C:\\Data\\PDF_files\\ - do not use directories containing spaces - Format - string

    filenameformat : The format of the data file name. The data files should be named in a way to allow them to be cycle
                    over easily, e.g. if you have neutron PDF data for Barium Titanate at 150 K, 200 K, 250 K etc., they
                    should be named something like BaTiO3_NPDF_125K.xye . To allow cycling, the filenameformat is then
                    BaTiO3_NPDF_##n##K.xye - Format : string

    isneutron : Set this to True if your data is neutron data - Format : Boolean

    qmax : The maximum Q value used when generating the PDFs. If this value is not constant, please see examples for
        cycling through additional variables. Format - string

    islor : Set this to true if you are using Lorentzian damping. See "TOPAS Instrumental Functions for PDF Data" at
            https://www.diamond.ac.uk/Instruments/Crystallography/I15-1/Staff/Philip-Chater.html for more info
            Format - Boolean

    lor : Lorentzian damping value. Format - string

    dq : The dQ value for the PDFs, typically refined using a standard. Format - string

    isalpha : Set this to true if the alpha parameter for Q-dependent peak broadening is used. NOTE : this
              significantly slows down refinements. Format - Boolean

    alpha : Alpha value for Q-dependent peak broadening. Format - string

    isrebin : Set to true if you want to rebin your data. Format - Boolean

    bin : Data bin size. This is important, as Topas and Gudrun define bins differently, so an correction is
          made in the input file. Format - string

    startx : Radius to start refinements at. Due to the convolution with a sinc function, it is not recommended
            to reduce this below 1.0. Format - string

    finishx : Upper value for fitting data. Data is only fitted for radii between startx -> finishx
              Format - string

    filename : name of input file for writing and execution. The default is batch_modes.inp - note the extension is
                required. Format - string

    lattice : Defines the restraints on lattice parameters. Permitted values are "C", "T" or "O"
                For "C", all lattice parameters are restricted to be equal
                For "T", a and b are given the value for cell_length_a and restricted to be equal.
                For "O", a, b and c refine freely.

    topaspath : The path that contains the topas executables. Format - string

    temps : A list of temperatures or other variable to iterate over. The elements in this list replace the ##n##
            in the filenameformat argument. Format - list of strings



    Methods
    -------
    sapa(cif_file) : imports the ISODISTORT cif file - this is the main function of the class

    write_inp(sample,cycles,path,filenameformat,isneutron,qmax,islor,dq,isalpha,startx,finishx,
            isrebin,bin="0.02",lor="0.0",alpha="0.0",filename="batch_modes.inp") : generates a topas input file for
            SAPA

    execute(filename,topaspath,temps) : executes the topas input file. Output files are generated with the format
        IRREP_sample_TEMP_out.txt for each irrep and temperature. These can be interacted with using the sapa_utils
        class

    irrep_list() : writes a list of the irreps defined in the ISODISTORT CIF

    Variables
    ---------

    Any variables defined in the CIF can be accessed as a class variable. These are strings, for isolated values, or
    lists of strings, for any variable defined within a loop_ in the CIF.  For example:
    C:\working_dir\> import sapa as s
    C:\working_dir\> struc = s.sapa("batio3_iso.cif")
    C:\working_dir\> print(struc.iso_displacivemode_label) -> this line prints the iso_displacivemode_label list
    """

    def __init__(self, cif_file):

        self.wd = os.getcwd()
        f = open(cif_file, "r")
        lines = f.readlines()
        count = 0
        count_cifloop = 0
        for n in range(0, len(lines)):
            line = lines[n]
            # reads single value entry in cif file and creats a class attribute with value stored as str
            if line[0] == "_" and len(line.split()) == 2:
                vars(self)['%s' % (line.split()[0].lstrip(
                    "_").strip())] = line.split()[1]

            # reads single line entries in cif file where data is on the next line
            # if line[0] == "_" and len(line.split())==1 and r'[\t]' not in line and lines[n+1][0] != '_':
            #   vars(self)['%s'%(line.lstrip("_").rstrip("\n").strip())] = lines[n+1].strip().sub(r'[\t]', '').rstrip("\n")

            # reads multiline entries in table format....
            if line[0:5] == "loop_":
                n = n + 1
                m = 0
                while "_" in lines[n + m][0]:
                    vars(self)['%s' %
                               (lines[n + m].lstrip("_").rstrip("\n"))] = []
                    m = m + 1
                    # work out out many columns the mutiline entreis have....
                q = 0
                while len(lines[n + m + q]) > 2 and "loop_" not in lines[n + m + q] and "#" not in lines[n + m + q]:
                    k = 0

                    for k in range(m):
                        # each multiline becomesa. a attribute of the class with the associated value set.
                        try:
                            vars(self)['%s' % (
                                lines[n + k].lstrip("_").rstrip("\n").strip())].append(lines[n + m + q].split()[k])
                        except:
                            print("cif file error in %s at line %d" %
                                  (cif_file, n))
                    q = q + 1
                    count_cifloop = q + m

            # interate forwards so that I don't re-read the cif.
            n = n + count_cifloop

        f.close()

    # converts any matricies in cif loop format in matrix foramt
    def make_matrices(self):
        for class_attribute in dir(self):
            if "_row" in class_attribute:
                rows = np.array(vars(self)['%s' %
                                           class_attribute]).astype(np.int)
                cols = np.array(vars(self)['%s_col' %
                                           class_attribute[:-4]]).astype(np.int)
                values = vars(self)['%s_value' % class_attribute[:-4]]
                cif_loop_matrix = np.zeros([max(rows), max(cols)])
                # print rows
                # print cols
                for val_index in range(len(values)):
                    cif_loop_matrix[rows[val_index] - 1,
                                    cols[val_index] - 1] = values[val_index]

                vars(self)['%s_matrix' % class_attribute[:-4]
                           ] = np.matrix(cif_loop_matrix)

    # takes mode matrix
    def constraint_array(self, mode_number):
        mode_matrix = self.iso_displacivemodematrix_matrix
        if (len(mode_matrix[:, 0]) >= mode_number) and (mode_number > 0):
            vector = np.zeros([len(mode_matrix[:, 0]), 1])
            vector[mode_number - 1, 0] = 1
            return mode_matrix * vector

        else:
            print("mode number is outside range")
            return 0

        # split constraints up into x, y and z array.

    def make_x_y_z_constrains(self, c_array):
        # make x, y, z array
        xyz_label = self.iso_deltacoordinate_label
        c_x = []  # np.zeros[len(xyz_label)/3,1]
        c_y = []  # np.zeros[len(xyz_label)/3,1]
        c_z = []  # np.zeros[len(xyz_label)/3,1]
        for i in range(len(c_array) / 3):
            c_x.append(c_array[i * 3, 0])
            c_y.append(c_array[(i * 3) + 1, 0])
            c_z.append(c_array[(i * 3) + 2, 0])

        return c_x, c_y, c_z

    # method to return constraints all in one step.
    def constraints_out(self, mode_number):
        self.make_matrices()
        c_array = self.constraint_array(mode_number)
        c_x, c_y, c_z = self.make_x_y_z_constrains(c_array)
        # print c_x, c_y, c_z
        return c_x, c_y, c_z

    #searches CIF for irreps

    def irrep_list(self):
        irreps = []
        #check if CIF has displacive or occupancy modes
        # irreps in iso_displacivemode_label always are between the first ] and ( characters

        if hasattr(self, "iso_displacivemode_label"):
            for i in self.iso_displacivemode_label:

                m = re.search("\](.+?)\(", i)
                if m:
                    label = m.group(1)
                    irreps.append(label)
        elif hasattr(self, "iso_occupancymode_label"):
            for i in self.iso_occupancymode_label:
                m = re.search("\](.+?)\(", i)
                if m:
                    label = m.group(1)
                    irreps.append(label)
        irreps = list(dict.fromkeys(irreps))
        return irreps

    #construct control and instrument parameter section of input file
    def instrument_pars(self, cycles, path, filenameformat, isneutron, qmax, lor, dq, alpha, startx, finishx, isrebin,
                        rebindx, soperlorch, version):
        entry = "'{{{ ===R-factors and control information==="
        entry += "r_wp 0.0 r_exp 0.0 r_p 0.0 r_wp_dash 0.0 r_exp_dash 0.0 weighted_Durbin_Watson 0.0 gof 0.0 \n"
        entry += "iters 10000000 \n"
        entry += "chi2_convergence_criteria 0.001 \n"
        entry += "continue_after_convergence \n"
        entry += "prm dummy  0.00000` val_on_continue = If(Cycle == {0}, Get(iters) = 0, 0); \n".format(cycles)
        entry += "'}}}"
        entry += "\n"
        entry += "'{{{ ===File Input and Instrumental Parameters==="
        entry += " \' File input macro example. The ##n## is replaced when called. \n"
        entry += "macro file_in_(n) \n"
        if path.endswith("\\") == False:
            entry += "{\n %s\\%s \n" % (path, filenameformat)
        else:
            entry += "{\n %s%s \n" % (path, filenameformat)
        entry += "} \n"
        entry += "xdd file_in_(VAR) \n"
        entry += "   weighting = 1; \n"
        if isneutron == True:
            entry += "   neutron_data \n"
        entry += "pdf_data \n"
        if version == "6":
            entry+= "   rebin_start_x_at 0 \n"
            entry += "   rebin_with_dx_of %s \n" % rebindx
        entry += "start_X {0} \n".format(startx)
        entry += "finish_X {0} \n" .format(finishx)
        if lor != 0:
            entry += " dQ_lor_damping(!dQ,{0},!lor,{1}) \n".format(dq, lor)
            print(f'Using Lorentzian contribution to dQ of {lor}')
        else:
            entry += "   dQ_damping(!dQ,{0}) \n".format(dq)
        entry += "   convolute_Qmax_Sinc(!Qmax,{0}) \n".format(qmax)
        if alpha != 0:
            print("Warning: use of alpha parameter significantly slows down refinements")
            entry += " convolute_alpha(!alpha,{0}) \n".format(alpha)
        if soperlorch != 0:
            print(f'Correcting for Soper-Lorch function with broadening of {soperlorch}')
            entry += f'convolute_SoperLorch(!d_zero, {soperlorch}) \n'

        entry += "'}}}"
        return entry

    def phase(self, bin, lattice, refine_angles):
        zero = float(bin) / 2
        zero = str(zero)
        entry = "\'{{{=== PHASE INFORMATION === \n"
        entry += "      str \n"
        entry += f"         a lprm_a {self.cell_length_a} \n"
        if lattice in ["C", "R"]:
            entry += "         b lprm_b = lprm_a; \n"
            entry += "         c lprm_c = lprm_a; \n"
        elif lattice in ["T", "H"]:
            entry += "         b lprm_b = lprm_a; \n"
            entry += f"         c lprm_c {self.cell_length_c} \n"
        elif lattice in ["O", "TC", "M"]:
            entry += f"         b lprm_b {self.cell_length_b} \n"
            entry += f"         c lprm_c {self.cell_length_c} \n"

        else:
            print("Unexpected value for lattice argument. Expected C, T, R, H, TC, M or O. Exiting...")
            

        if refine_angles == False:
            entry += f"         al !lprm_al {self.cell_angle_alpha} \n"
            entry += f"         be !lprm_be {self.cell_angle_beta} \n"
            entry += f"         ga !lprm_ga {self.cell_angle_gamma} \n"

        elif refine_angles == True:
            entry += f"         al lprm_al {self.cell_angle_alpha} \n"
            entry += f"         be lprm_be {self.cell_angle_beta} \n"
            entry += f"         ga lprm_ga {self.cell_angle_gamma} \n"


        entry += "         volume %s \n" % self.cell_volume
        entry += "         space_group %s \n" % self.symmetry_Int_Tables_number
        entry += "         pdf_zero -%s \n" % zero
        entry += "'}}}"
        entry += "\n \n \n \n"
        return entry

    def modes(self, normalise=True):
        irreps = self.irrep_list()
        entry = "\'{{{====== MODE DEFINITIONS ===== \n"
        # creating the #ifdef and #ifndef blocks for each irrep
        # position in iso_label list of each irrep corresponds to position in transformation matrix
        # prm name is a{column}
        norm_vals = self.iso_displacivemodenorm_value
        iso_label = self.iso_displacivemode_label
        for irrep in irreps:
            entry += "'{{{" + f"==={irrep}=== \n"
            entry += "#ifndef %s \n" % irrep
            for i in range(len(iso_label)):
                m = re.search("\](.+?)\(", iso_label[i])
                if m:
                    label = m.group(1)
                    if irrep == label:
                        if normalise:
                            entry += f"prm !a{i + 1} 0.00000 min -{0.1/float(norm_vals[i])} max {0.1/float(norm_vals[i])} val_on_continue = Rand({-0.05/float(norm_vals[i])},{0.05//float(norm_vals[i])}); \' {iso_label[i]} \n"
                        else:

                            entry += f"prm !a{i + 1} 0.00000 min -0.1 max 0.1 val_on_continue = Rand(-0.05,0.05); \' {iso_label[i]} \n"
            entry += "#endif \n"
            entry += "#ifdef %s \n" % irrep
            for i in range(len(iso_label)):
                m = re.search("\](.+?)\(", iso_label[i])
                if m:
                    label = m.group(1)
                    if irrep == label:
                        if normalise:
                            entry += f"prm a{i + 1} 0.00000 min -{0.1 / float(norm_vals[i])} max {0.1 / float(norm_vals[i])} val_on_continue = Rand({-0.05 / float(norm_vals[i])},{0.05 // float(norm_vals[i])}); \' {iso_label[i]} \n"
                        else:
                            f"prm a{i + 1} 0.00000 min -0.1 max 0.1 val_on_continue = Rand(-0.05,0.05); \' {iso_label[i]} \n"
            entry += "#endif \n"
            entry += "'}}} \n"
        entry += "'}}}"
        entry += "\n \n \n \n"
        entry += "\'{{{===== MODE TO DELTAS TRANSFORMATION ===== \n"
        # write the matrix transformation
        # for each deltacoordinate, e.g. site1_dx, the script finds the non-zero columns and converts to parameter names
        # deltacoord_j = sum_i(dmval_ij*a_i)
        dm_rows = self.iso_displacivemodematrix_row
        dm_cols = self.iso_displacivemodematrix_col
        dm_vals = self.iso_displacivemodematrix_value
        dc_labels = self.iso_deltacoordinate_label


        for i in range(len(dc_labels)):
            dc_cols = []
            dc_vals = []
            dc_norms = []
            entry += f"prm {dc_labels[i]} ="
            for j in range(len(dm_rows)):

                if int(dm_rows[j]) == i + 1:
                    dc_cols.append(dm_cols[j])
                    dc_vals.append(dm_vals[j])
                    dc_norms.append(norm_vals[int(dm_cols[j])-1])

            if normalise:
                for j in range(len(dc_cols)):
                    if j == len(dc_cols) - 1:
                        if float(dc_vals[j]) > 0:
                            entry += f" + {dc_vals[j]}*{dc_norms[j]}*a{dc_cols[j]} ;: 0.0 \n"
                        else:
                            dcv = dc_vals[j][1:]
                            entry += f" - {dcv}*{dc_norms[j]}*a{dc_cols[j]} ;: 0.0\n"
                    else:
                        if float(dc_vals[j]) > 0:
                            entry += f" + {dc_vals[j]}*{dc_norms[j]}*a{dc_cols[j]} "
                        else:
                            dcv = dc_vals[j][1:]
                            entry += f" - {dcv}*{dc_norms[j]}*a{dc_cols[j]} "
            else:

                for j in range(len(dc_cols)):
                    if j == len(dc_cols) - 1:
                        if float(dc_vals[j]) > 0:
                            entry += " + %s*a%s ;: 0.0 \n" % (dc_vals[j], dc_cols[j])
                        else:
                            entry += " %s*a%s ;: 0.0\n" % (dc_vals[j], dc_cols[j])
                    else:
                        if float(dc_vals[j]) > 0:
                            entry += " + %s*a%s " % (dc_vals[j], dc_cols[j])
                        else:
                            entry += " %s*a%s " % (dc_vals[j], dc_cols[j])
        entry += "'}}}"
        entry += "\n"
        entry += "'{{{ ===Site Definitions==="
        # define site coordinates, e.g. site_distorted_x = site_x + site_dx
        icl = self.iso_coordinate_label
        print(len(icl))
        icf = self.iso_coordinate_formula
        entry += "\n"
        xs = self.atom_site_fract_x
        ys = self.atom_site_fract_y
        zs = self.atom_site_fract_z
        formula = []
        for i in range(len(xs)):
            formula.append(xs[i])
            formula.append(ys[i])
            formula.append(zs[i])
        print(len(formula))
        for i in range(len(icl)):
            # formula = icf[i].strip("\"")
            entry += "prm %s = %s + %s;\n" % (icl[i], formula[i], dc_labels[i])

        entry += "\n"
        #get list of elements involved - this is used for beq function
        atoms = self.atom_site_type_symbol
        elements = set(atoms)
        elements = list(elements)
        elements = [x.strip("+-123456789") for x in elements]
        beq_vars = []
        for i in elements:
            bv = i + "_beq"
            beq_vars.append(bv)
        for i in beq_vars:
            entry += "prm %s 0.01 min 0 max 1 val_on_continue = Rand(0,0.1); \n" % i
        entry += "prm rv 0.01 min 0 val_on_continue = Rand(0,0.1); \n"
        entry += "prm r2v 0.01 min 0 val_on_continue = Rand(0,0.1); \n"
        entry += "prm phase_scale 1 \n"
        sites = self.atom_site_label
        occs = self.atom_site_occupancy
        for i in range(len(sites)):
            entry += "site %s " % sites[i]
            entry += " x = %s; " % icl[3 * i]
            entry += " y = %s; " % icl[3 * i + 1]
            entry += " z = %s; " % icl[3 * i + 2]
            entry += " occ %s %s " % (atoms[i].strip("+-123456789"), occs[i])
            for j in range(len(elements)):
                if atoms[i].strip("+-123456789") == elements[j]:
                    bn = "beq_" + str(i)
                    entry += "beq_r_r2(%s,=%s;,d1,=rv;,d2,=r2v;) \n" % (bn, beq_vars[j])
        entry += "scale = phase_scale; \n"
        entry += "'}}} \n"
        return entry

    def output(self, sample):
        entry = "'{{{ ===Output Macros=== \n"
        entry += f"macro ycalc_out_(u,v) \n {{ \n {self.sample}_##u##_##v##_ycalc.txt \n }} \n \n"
        entry += "Out_X_Ycalc(ycalc_out_(IRREP,VAR)) \n \n"
        entry += f"macro yobs_out_(u,v) \n {{ \n {self.sample}_##u##_##v##_yobs.txt \n }} \n \n"
        entry += "Out_X_Yobs(yobs_out_(IRREP,VAR)) \n \n"
        entry += "macro file_out_(m,n) \n { \n m##_%s_##n##_out.txt \n } \n" % sample
        entry += "out_prm_vals_on_convergence file_out_(IRREP,VAR) out_prm_vals_dependents_filter \"lprm_*\" \n"
        entry += "'}}}"

        return entry

    def write_inp(self, sample, filenameformat, isneutron, qmax, dq, startx, finishx, lattice, path=os.getcwd(), cycles=300,
                  isrebin=False, bin="0.02", lor=0, alpha=0, soperlorch=0, filename="batch_modes.inp", refine_angles=False, version = "7", singlemode = False, normalise=True):
        print("Creating input file...")
        self.filename = filename
        self.sample = sample

        entry = self.instrument_pars(cycles, path, filenameformat, isneutron, qmax, lor, dq, alpha,
                                     startx, finishx, isrebin, soperlorch=soperlorch, rebindx=bin, version=version)
        entry += self.phase(bin, lattice, refine_angles)
        if singlemode:
            entry += self.modes_single()
            entry += self.output_single(sample)
        else:
            entry += self.modes()
            entry += self.output(sample)
        f = open(filename, "w")
        f.write(entry)
        f.close()
        self.meta = f"Run {sample} was executed with a fitting range of {startx}-{finishx} angstrom, with {cycles} cycles per irrep. Instrumental values of qmax = {qmax}, dq = {dq}, lor = {lor}, soperlorch = {soperlorch} and alpha = {alpha}."
        print("...%s written" % filename)

    def execute(self, temps, var_dict = {}, verbose=False, skip_irreps = []):
        if type(temps) is not list:
            temps = list(temps)
        temps = [str(x) for x in temps]
        self.temps = temps
        print("Finding Topas executables...")
        for root, dirs, files in os.walk("C:\\", topdown=False):
            for name in files:
                if name == "tc.exe":
                    topaspath = os.path.join(root, name)
                    dirs[:] = []
                    break
        if not hasattr(self, "filename"):
            self.filename = input("Enter filename: ")
            if self.filename.endswith(".inp") == False:
                self.filename += ".inp"

        if not hasattr(self, "sample"):
            self.sample = input("Enter sample name for this run: ")

        irreps = self.irrep_list()
        irreps.append("nomodes")
        if skip_irreps:
            irreps = [x for x in irreps if x not in skip_irreps]

        inppath = os.path.join(self.wd, self.filename)

        print("Creating Monitoring File...")
        f = open("%s_monitor.txt" % self.sample, "w")
        f.write("Temp   Irrep   Executed \n")
        for temp in temps:
            for irrep in irreps:
                f.write("{0} {1}  False \n".format(temp, irrep))
        f.close()
        f = open("%s_monitor.txt" % self.sample, "r")
        lines = f.readlines()
        f.close()
        print("Executing...")

        totaltime = 0
        for i in range(1, len(lines)):
            ex_string = topaspath + " " + "\"" + inppath + "\""
            args = lines[i].split()
            temp = args[0]
            irrep = args[1]
            start = time.time()
            print("Executing irrep %s for temp %s" % (irrep, temp))
            ex_string += f' \" macro IRREP {{{irrep}}} macro VAR {{{temp}}} '
            if var_dict:
                for key in var_dict:
                    in_val = var_dict[key][temps.index(temp)]
                    ex_string += f' macro {key} {{{in_val}}}'
            ex_string += f'#define {irrep} \"'
            if verbose == False:
                os.system(ex_string + " > NUL ")
            else:
                os.system(ex_string)
            lines[i] = f"{temp}  {irrep}  True \n"
            with open("%s_monitor.txt" % self.sample, "w") as file:
                file.writelines(lines)
            end = time.time()
            processtime = end - start
            totaltime += processtime
            averagetime = totaltime / float(i)
            remainingtime = (averagetime * (len(lines) - i - 1)) / 3600
            print("Completed irrep {0} for temp {1}. Process took {2}s ({3} minutes)".format(irrep, temp, processtime,
                                                                                             processtime / 60))
            print("Estimated {0} hours to completion.".format(remainingtime))

    def restart(self):
        print("Finding Topas executables...")
        for root, dirs, files in os.walk("C:\\", topdown=False):
            for name in files:
                if name == "tc.exe":
                    topaspath = os.path.join(root, name)
                    dirs[:] = []
                    break

        if not hasattr(self, "filename"):
            self.filename = input("Enter filename: ")
            if self.filename.endswith(".inp") == False:
                self.filename += ".inp"

        if not hasattr(self, "sample"):
            self.sample = input("Enter sample name to restart: ")

        f = open("%s_monitor.txt" % self.sample, "r")
        lines = f.readlines()
        f.close()

        irreps = self.irrep_list()
        irreps.append("nomodes")
        wd = os.getcwd()
        inppath = os.path.join(wd, self.filename)
        totaltime = 0
        print("Restarting...")
        j = 0
        for i in range(1, len(lines)):
            args = lines[i].split()
            temp = args[0]
            irrep = args[1]

            if args[2] == "False":
                j += 1
                start = time.time()
                print("Executing irrep %s for temp %s" % (irrep, temp))
                os.system(topaspath + " " + inppath + "   \" macro IRREP {%s} macro VAR {%s} #define %s \" > NUL" % (
                irrep, temp, irrep))
                lines[i] = "%s  %s  True \n" % (temp, irrep)
                with open("%s_monitor.txt" % self.sample, "w") as file:
                    file.writelines(lines)
                end = time.time()
                processtime = end - start
                totaltime += processtime
                averagetime = totaltime / float(j)
                remainingtime = (averagetime * (len(lines) - i - 1)) / 3600
                print(
                    "Completed irrep {0} for temp {1}. Process took {2}s ({3} minutes)".format(irrep, temp, processtime,
                                                                                               processtime / 60))
                print("Estimated {0} hours to completion.".format(remainingtime))

    def idformat(self, path):
        data = os.listdir(f"./{path}")
        seq = dl.SequenceMatcher(None, data[0], data[1])
        blocks = seq.get_matching_blocks()
        string = data[1]
        start = string[blocks[0][0]:blocks[0][2]]
        end = string[blocks[1][0]:]
        start_lens = []
        end_lens = []
        for i in range(2, len(data)):
            start_diff = dl.SequenceMatcher(None, start, data[i])
            start_blocks = start_diff.get_matching_blocks()
            start_lens.append(start_blocks[0][2])
            end_diff = dl.SequenceMatcher(None, end, data[i])
            end_blocks = end_diff.get_matching_blocks()
            end_lens.append(end_blocks[0][2])
        start_min = min(start_lens)
        end_min = -1 * min(end_lens)
        start_string = string[:start_min]
        end_string = string[end_min:]
        print(start_string, end_string)
        return start_string, end_string

    def create_hdf5_base(self, temps, skip_irreps=[], index=[]):

        if not hasattr(self, "sample"):
            self.sample = input("Enter sample name to create hdf file for: ")


        if not hasattr(self, "meta"):
            self.meta = input("Enter some information to store to remind you of parameters used in this sapa run: ")

        hdf = h5py.File(f"{self.sample}.hdf5","w")
        hdf.attrs["metadata"] = self.meta
        if index:
            tempsf = [float(x) for x in index]
        else:
            tempsf = [float(x) for x in temps]
        temp_arr = np.asarray(tempsf)
        hdf["temps"] = temp_arr
        irreps = self.irrep_list()
        if skip_irreps:
            irreps = [x for x in irreps if x not in skip_irreps]

        hdf.attrs["irreps"] = irreps
        df_calc = pd.read_csv(f"{self.sample}_{irreps[0]}_{temps[0]}_ycalc.txt", sep=r"\s+", index_col=None,
                              names=["x", "ycalc"])

        hdf.create_dataset("r_vals", data = np.asarray(df_calc["x"]))

        grp = hdf.create_group("nomodes")
        grp.create_dataset("ycalc", (len(temps), len(df_calc["ycalc"])))
        grp.create_dataset("yobs", (len(temps), len(df_calc["ycalc"])))
        for i in range(len(temps)):
            temp = temps[i]
            temp = temps[i]
            df_c = pd.read_csv(f"{self.sample}_nomodes_{temp}_ycalc.txt", sep=r"\s+", index_col=None,
                               names=["x", "ycalc"], header=None)
            df_o = pd.read_csv(f"{self.sample}_nomodes_{temp}_yobs.txt", sep=r"\s+", index_col=None,
                               names=["x", "yobs"], header=None)
            dset = grp["ycalc"]
            dset[i, :] = np.asarray(df_c["ycalc"])
            dset = grp["yobs"]
            dset[i, :] = np.asarray(df_o["yobs"])


        for irrep in irreps:
            grp = hdf.create_group(f"{irrep}")
            dfn = pd.read_csv(f"{irrep}_{self.sample}_{temps[0]}_out.txt",sep=r"\s+",index_col=None)
            dfn = dfn.drop([0])
            num_cycles = len(dfn["Rwp"])
            dfn = dfn.drop(["Cycle", "Iter"], axis=1)
            prms = dfn.columns
            for prm in prms:
                grp.create_dataset(prm, (len(temps), num_cycles))
                hdf[f"{irrep}/{prm}"].dims[0].label = "Temps"
            grp.create_dataset("delrwp", (len(temps), num_cycles))
            if hasattr(self, "iso_displacivemodenorm_value") and not hasattr(self, "iso_occupancymodenorm_value"):
                regex = re.compile(r"^a[0-9]+")
                mode_prms = [x for x in prms if regex.search(x)]
                mode_inds = [int(str(x).lstrip("a")) - 1 for x in mode_prms]
                norms = []
                for i in mode_inds:
                    norms.append(float(self.iso_displacivemodenorm_value[i]))
            elif hasattr(self, "iso_occupancymodenorm_value") and not hasattr(self, "iso_displacivemodenorm_value"):
                regex = re.compile(r"^b[0-9]+")
                mode_prms = [x for x in prms if regex.search(x)]
                mode_inds = [int(str(x).lstrip("b")) - 1 for x in mode_prms]
                norms = []
                for i in mode_inds:
                    norms.append(float(self.iso_occupancymodenorm_value[i]))
            norms = np.asarray(norms)
            #print(irrep, norms)
            grp.create_dataset("norms", data=norms)
            grp.create_dataset("mode_amps", (len(temps), num_cycles))
            grp.create_dataset("ycalc", (len(temps), len(df_calc["ycalc"])))
            grp.create_dataset("yobs", (len(temps), len(df_calc["ycalc"])))



            for i in range(len(temps)):
                temp = temps[i]
                fn = f"{irrep}_{self.sample}_{temp}_out.txt"
                df = pd.read_csv(fn,sep=r"\s+",index_col=None)
                df = df.drop([0])
                df = df.sort_values("Rwp")
                df.index = range(len(df.index))
                df = df.drop(["Cycle", "Iter"], axis = 1)
                names = df.columns
                for name in names:
                    data = np.asarray(df[name])
                    #print(name, temp,data.shape)
                    dset = grp[name]
                    dset[i,0:len(data)] = data

                nmdf = pd.read_csv(f"nomodes_{self.sample}_{temp}_out.txt",sep=r"\s+",index_col=None)
                nmdf = nmdf.drop([0])
                nmdf = nmdf.sort_values("Rwp")
                nmdf.index = range(len(nmdf.index))
                nm_rwp = nmdf.at[0, "Rwp"]

                rwp = np.asarray(df["Rwp"])
                delrwp = rwp - nm_rwp
                dset = grp["delrwp"]
                dset[i,0:len(delrwp)] = delrwp

            for i in range(len(temps)):
                temp = temps[i]
                fn = f"{irrep}_{self.sample}_{temp}_out.txt"
                df = pd.read_csv(fn, sep=r"\s+", index_col=None)
                df = df.drop([0])
                df = df.sort_values("Rwp")
                df.index = range(len(df.index))
                df["mode_amps"] = (df[mode_prms[0]] / norms[0]) ** 2
                for j in range(1, len(norms)):
                    df["mode_amps"] += (df[mode_prms[j]] / norms[j]) ** 2
                df["mode_amps"] = np.sqrt(df["mode_amps"])
                dset = grp["mode_amps"]
                ma_data = np.asarray(df["mode_amps"])
                dset[i,0:len(ma_data)] = ma_data


            for i in range(len(temps)):
                temp = temps[i]
                df_c = pd.read_csv(f"{self.sample}_{irrep}_{temp}_ycalc.txt", sep=r"\s+", index_col=None,
                                      names=["x", "ycalc"], header=None)
                df_o = pd.read_csv(f"{self.sample}_{irrep}_{temp}_yobs.txt", sep=r"\s+", index_col=None,
                                      names=["x", "yobs"], header=None)
                dset = grp["ycalc"]
                dset[i,:] = np.asarray(df_c["ycalc"])
                dset = grp["yobs"]
                dset[i,:] = np.asarray(df_o["yobs"])











        self.temps = temps
        hdf.close()

    def cleanup(self, create_zip = True, skip_irreps = []):

        if not hasattr(self, "sample"):
            self.sample = input("Enter sample name to clean up: ")

        if not hasattr(self, "temps"):
            self.temps = input(f"Enter temps for sample {self.sample}: ")

        irreps = self.irrep_list()
        irreps.append("nomodes")
        if skip_irreps:
            irreps = [x for x in irreps if x not in skip_irreps]

        if create_zip:
            print("Creating zip file...")
            zipObj = ZipFile(f"{self.sample}.zip","w")

            for irrep in irreps:
                for temp in self.temps:
                    zipObj.write(f"{irrep}_{self.sample}_{temp}_out.txt")
                    zipObj.write(f"{self.sample}_{irrep}_{temp}_ycalc.txt")
                    zipObj.write(f"{self.sample}_{irrep}_{temp}_yobs.txt")
            zipObj.close()
            print("...Zip file written.")


        print("Deleting .txt files...")
        for irrep in irreps:
            for temp in self.temps:
                os.remove(f"{irrep}_{self.sample}_{temp}_out.txt")
                os.remove(f"{self.sample}_{irrep}_{temp}_ycalc.txt")
                os.remove(f"{self.sample}_{irrep}_{temp}_yobs.txt")
        print("...Clean up complete.")


    def file_check(self, temps, cycles=300, verbose=True, skip_irreps = []):
        f = open(f"{self.sample}_rerun.txt","w")
        f.write("Temp Irrep Re-ran \n")
        irreps = self.irrep_list()
        irreps.append("nomodes")
        if skip_irreps:
            irreps = [x for x in irreps if x not in skip_irreps]
        for temp in temps:
            for irrep in irreps:
                #if not (os.path.isfile(f"{self.sample}_{irrep}_{temp}_ycalc.txt") and os.path.isfile(f"{self.sample}_{irrep}_{temp}_yobs.txt")):
                    #f.write(f"{temp} {irrep} False \n")
                if os.path.exists(f"{irrep}_{self.sample}_{temp}_out.txt"):
                    outf = open(f"{irrep}_{self.sample}_{temp}_out.txt","r")
                    nlines = len(outf.readlines())
                    #Topas does a zeroth cycle that is discarded in sapa when writing hdf5 file
                    #nlines should = cycles + 2 due to zeroth cycle and header
                    if nlines != cycles + 2:
                        f.write(f"{temp} {irrep} False \n")

                if not os.path.exists(f"{irrep}_{self.sample}_{temp}_out.txt"):
                    f.write(f"{temp} {irrep} False \n")
        f.close()

        f = open(f"{self.sample}_rerun.txt", "r")
        lines = f.readlines()
        f.close()

        if len(lines) == 1:
            print("Files checked, found no issues!")

        else:

            print("Finding Topas executables...")
            for root, dirs, files in os.walk("C:\\", topdown=False):
                for name in files:
                    if name == "tc.exe":
                        topaspath = os.path.join(root, name)
                        dirs[:] = []
                        break
            if not hasattr(self, "filename"):
                self.filename = input("Enter filename: ")
                if self.filename.endswith(".inp") == False:
                    self.filename += ".inp"

            inppath = os.path.join(self.wd, self.filename)


            print("Executing...")
            totaltime = 0
            for i in range(1, len(lines)):
                args = lines[i].split()
                temp = args[0]
                irrep = args[1]
                start = time.time()
                print("Executing irrep %s for temp %s" % (irrep, temp))
                if verbose == False:
                    os.system(
                        topaspath + " " + "\"" + inppath + "\"" + "   \" macro IRREP {{{0}}} macro VAR {{{1}}} #define {0} \" > NUL ".format(
                            irrep, temp))
                else:
                    os.system(
                        topaspath + " " + "\"" + inppath + "\"" + "   \" macro IRREP {{{0}}} macro VAR {{{1}}} #define {0} \" ".format(
                            irrep,
                            temp))
                lines[i] = "{0}  {1}  True \n".format(temp, irrep)
                with open("%s_monitor.txt" % self.sample, "w") as file:
                    file.writelines(lines)
                end = time.time()
                processtime = end - start
                totaltime += processtime
                averagetime = totaltime / float(i)
                remainingtime = (averagetime * (len(lines) - i - 1)) / 3600
                print("Completed irrep {0} for temp {1}. Process took {2}s ({3} minutes)".format(irrep, temp, processtime,
                                                                                                 processtime / 60))
                print("Estimated {0} hours to completion.".format(remainingtime))

    def execute_occ(self, temps, occupancies, verbose=False, skip_irreps = []):
        # IMPORTANT: temps is just a placeholder name, it should be a list of filename components that complete the filename format
        self.temps = temps
        print("Finding Topas executables...")
        for root, dirs, files in os.walk("C:\\", topdown=False):
            for name in files:
                if name == "tc.exe":
                    topaspath = os.path.join(root, name)
                    dirs[:] = []
                    break
        if not hasattr(self, "filename"):
            self.filename = input("Enter filename: ")
            if self.filename.endswith(".inp") == False:
                self.filename += ".inp"

        if not hasattr(self, "sample"):
            self.sample = input("Enter sample name for this run: ")

        irreps = self.irrep_list()
        if skip_irreps:
            irreps = [x for x in irreps if x not in skip_irreps]
        irreps.append("nomodes")

        inppath = os.path.join(self.wd, self.filename)

        print("Creating Monitoring File...")
        f = open("%s_monitor.txt" % self.sample, "w")
        f.write("Occupancy   Irrep   Executed \n")
        for temp in temps:
            for irrep in irreps:
                f.write("{0} {1}  False \n".format(temp, irrep))
        f.close()
        f = open("%s_monitor.txt" % self.sample, "r")
        lines = f.readlines()
        f.close()
        ex_string =  topaspath + " " + "\"" + inppath + "\""
        print("Executing...")
        totaltime = 0
        for i in range(1, len(lines)):
            args = lines[i].split()
            temp = args[0]
            occ = occupancies[temps.index(temp)]
            irrep = args[1]
            start = time.time()
            print("Executing irrep %s for temp %s" % (irrep, temp))
            if verbose == False:
                os.system(
                    ex_string + "   \" macro IRREP {{{0}}} macro VAR {{{1}}} macro OCC {{{2}}} #define {0} \" > NUL ".format(
                        irrep, temp, occ))
            else:
                os.system(
                    ex_string + "   \" macro IRREP {{{0}}} macro VAR {{{1}}} macro OCC {{{2}}} #define {0} \" ".format(
                        irrep,
                        temp, occ))
            lines[i] = "{0}  {1}  True \n".format(temp, irrep)
            with open("%s_monitor.txt" % self.sample, "w") as file:
                file.writelines(lines)
            end = time.time()
            processtime = end - start
            totaltime += processtime
            averagetime = totaltime / float(i)
            remainingtime = (averagetime * (len(lines) - i - 1)) / 3600
            print("Completed irrep {0} for temp {1}. Process took {2}s ({3} minutes)".format(irrep, temp, processtime,
                                                                                             processtime / 60))
            print("Estimated {0} hours to completion.".format(remainingtime))

    def modes_single(self):
        irreps = self.irrep_list()
        entry = "\'{{{====== MODE DEFINITIONS ===== \n"
        iso_label = self.iso_displacivemode_label
        for i in range(len(iso_label)):
            entry += f'#ifndef mode{i+1} \n'
            entry += f'prm !a{i+1} 0.00000 min -0.1 max 0.1 val_on_continue = Rand(-0.05,0.05); \' {iso_label[i]} \n'
            entry += '#endif \n'
            entry += f'#ifdef mode{i + 1} \n'
            entry += f'prm a{i + 1} 0.00000 min -0.1 max 0.1 val_on_continue = Rand(-0.05,0.05); \' {iso_label[i]} \n'
            entry += '#endif \n'

        entry += "'}}}"
        entry += "\n \n \n \n"
        entry += "\'{{{===== MODE TO DELTAS TRANSFORMATION ===== \n"
        # write the matrix transformation
        # for each deltacoordinate, e.g. site1_dx, the script finds the non-zero columns and converts to parameter names
        # deltacoord_j = sum_i(dmval_ij*a_i)
        dm_rows = self.iso_displacivemodematrix_row
        dm_cols = self.iso_displacivemodematrix_col
        dm_vals = self.iso_displacivemodematrix_value
        dc_labels = self.iso_deltacoordinate_label

        for i in range(len(dc_labels)):
            dc_cols = []
            dc_vals = []
            entry += "prm %s =" % dc_labels[i]
            for j in range(len(dm_rows)):

                if int(dm_rows[j]) == i + 1:
                    dc_cols.append(dm_cols[j])
                    dc_vals.append(dm_vals[j])

            for j in range(len(dc_cols)):
                if j == len(dc_cols) - 1:
                    if float(dc_vals[j]) > 0:
                        entry += " + %s*a%s ;: 0.0 \n" % (dc_vals[j], dc_cols[j])
                    else:
                        entry += " %s*a%s ;: 0.0\n" % (dc_vals[j], dc_cols[j])
                else:
                    if float(dc_vals[j]) > 0:
                        entry += " + %s*a%s " % (dc_vals[j], dc_cols[j])
                    else:
                        entry += " %s*a%s " % (dc_vals[j], dc_cols[j])
        entry += "'}}}"
        entry += "\n"
        entry += "'{{{ ===Site Definitions==="
        # define site coordinates, e.g. site_distorted_x = site_x + site_dx
        icl = self.iso_coordinate_label
        print(len(icl))
        icf = self.iso_coordinate_formula
        entry += "\n"
        xs = self.atom_site_fract_x
        ys = self.atom_site_fract_y
        zs = self.atom_site_fract_z
        formula = []
        for i in range(len(xs)):
            formula.append(xs[i])
            formula.append(ys[i])
            formula.append(zs[i])
        print(len(formula))
        for i in range(len(icl)):
            # formula = icf[i].strip("\"")
            entry += "prm %s = %s + %s;\n" % (icl[i], formula[i], dc_labels[i])

        entry += "\n"
        # get list of elements involved - this is used for beq function
        atoms = self.atom_site_type_symbol
        elements = set(atoms)
        elements = list(elements)
        elements = [x.strip("+-123456789") for x in elements]
        beq_vars = []
        for i in elements:
            bv = i + "_beq"
            beq_vars.append(bv)
        for i in beq_vars:
            entry += "prm %s 0.01 min 0 max 1 val_on_continue = Rand(0,0.1); \n" % i
        entry += "prm rv 0.01 min 0 val_on_continue = Rand(0,0.1); \n"
        entry += "prm r2v 0.01 min 0 val_on_continue = Rand(0,0.1); \n"
        entry += "prm phase_scale 1 \n"
        sites = self.atom_site_label
        occs = self.atom_site_occupancy
        for i in range(len(sites)):
            entry += "site %s " % sites[i]
            entry += " x = %s; " % icl[3 * i]
            entry += " y = %s; " % icl[3 * i + 1]
            entry += " z = %s; " % icl[3 * i + 2]
            entry += " occ %s %s " % (atoms[i].strip("+-123456789"), occs[i])
            for j in range(len(elements)):
                if atoms[i].strip("+-123456789") == elements[j]:
                    bn = "beq_" + str(i)
                    entry += "beq_r_r2(%s,=%s;,d1,=rv;,d2,=r2v;) \n" % (bn, beq_vars[j])
        entry += "scale = phase_scale; \n"
        entry += "'}}} \n"
        return entry

    def output_single(self, sample):
        entry = "'{{{ ===Output Macros=== \n"
        entry += f"macro ycalc_out_(o,u,v) \n {{ \n mode##o##_{self.sample}_singlemode_##u##_##v##_ycalc.txt \n }} \n \n"
        entry += "Out_X_Ycalc(ycalc_out_(MODE,IRREP,VAR)) \n \n"
        entry += f"macro yobs_out_(o,u,v) \n {{ \n mode##o##_{self.sample}_singlemode_##u##_##v##_yobs.txt \n }} \n \n"
        entry += "Out_X_Yobs(yobs_out_(MODE,IRREP,VAR)) \n \n"
        entry += "macro file_out_(o,m,n) \n { \n mode##o##_##m##_%s_singlemode_##n##_out.txt \n } \n" % sample
        entry += "out_prm_vals_on_convergence file_out_(MODE,IRREP,VAR) out_prm_vals_dependents_filter \"lprm_*\" \n"
        entry += "'}}}"

        return entry


    def get_indices(self,irrep):


      indices = []
      iso_label = self.iso_displacivemode_label
      for i in range(len(iso_label)):
        m = re.search("\](.+?)\(",iso_label[i])
        if m:
            label = m.group(1)
            if irrep == label:
                indices.append(i)
      return indices

    def unique_modes(self, irrep):
        """returns unique mode numbers corresponding to variable names in topas"""
        #irreps = self.irrep_list()
        indices = self.get_indices(irrep)
        iso_label = self.iso_displacivemode_label
        uniques = []
        while indices:
            uniques.append(indices[0]+1)

            m = re.search("[a-zA-Z0-9_]+:[a-z]:(dsp|occ)", iso_label[indices[0]])
            type = m.group(0)

            m = re.search("\][a-zA-Z0-9'_]+\([a-z]", iso_label[indices[0]])
            char = m.group(0)
            char = char.rstrip(char[-1])

            toremove = [indices[0]]
            for index in indices:

                if (type in iso_label[index]) and (char in iso_label[index]):
                    toremove.append(index)
            indices = [x for x in indices if x not in toremove]

        return uniques




    def execute_single(self, temps, unique = True, verbose = False, skip_irreps = [], var_dict = {}):
        self.temps = temps
        print("Finding Topas executables...")
        for root, dirs, files in os.walk("C:\\", topdown=False):
            for name in files:
                if name == "tc.exe":
                    topaspath = os.path.join(root, name)
                    dirs[:] = []
                    break
        if not hasattr(self, "filename"):
            self.filename = input("Enter filename: ")
            if self.filename.endswith(".inp") == False:
                self.filename += ".inp"

        if not hasattr(self, "sample"):
            self.sample = input("Enter sample name for this run: ")

        irreps = self.irrep_list()
        #irreps.append("nomodes")
        if skip_irreps:
            irreps = [x for x in irreps if x not in skip_irreps]

        inppath = os.path.join(self.wd, self.filename)

        print("Creating Monitoring File...")
        f = open("%s_monitor.txt" % self.sample, "w")
        f.write("Temp   Mode   Irrep   Executed \n")

        for temp in temps:
            f.write(f'{temp} 0 nomodes False \n')
            for irrep in irreps:
                if unique:
                    uniques = self.unique_modes(irrep)
                    for i in uniques:
                        f.write(f'{temp} {i} {irrep} False \n')
                else:
                    iso_label = self.iso_displacivemode_label
                    for i in range(len(iso_label)):
                        m = re.search("\](.+?)\(", iso_label[i])
                        if m:
                            label = m.group(1)
                            if irrep == label:
                                #i+1 here since its an index
                                f.write(f'{temp} {i+1} {irrep} False \n')


        f.close()
        f = open("%s_monitor.txt" % self.sample, "r")
        lines = f.readlines()
        f.close()
        if unique:
            print("Executing only unique modes for each irrep...")
        else:
            print("Executing...")
        totaltime = 0
        for i in range(1, len(lines)):
            ex_string = topaspath + " " + "\"" + inppath + "\""
            args = lines[i].split()
            temp = args[0]
            mode = args[1]
            irrep = args[2]
            start = time.time()
            print("Executing mode %s , irrep %s for temp %s" % (mode,irrep, temp))
            ex_string += f' \" macro IRREP {{{irrep}}} macro VAR {{{temp}}} macro MODE {{{mode}}} '
            if var_dict:
                for key in var_dict:
                    in_val = var_dict[key][temps.index(temp)]
                    ex_string += f' macro {key} {{{in_val}}}'
            ex_string += f' #define mode{mode} \"'
            if verbose == False:
                os.system(ex_string + " > NUL ")
            else:
                os.system(ex_string)

            lines[i] = "{0} {2}  {1}  True \n".format(temp, irrep, mode)
            with open("%s_monitor.txt" % self.sample, "w") as file:
                file.writelines(lines)
            end = time.time()
            processtime = end - start
            totaltime += processtime
            averagetime = totaltime / float(i)
            remainingtime = (averagetime * (len(lines) - i - 1)) / 3600
            print("Completed mode {4} (irrep {0}) for temp {1}. Process took {2}s ({3} minutes)".format(irrep, temp, processtime,
                                                                                             processtime / 60, mode))
            print("Estimated {0} hours to completion.".format(remainingtime))


    def write_inp_single(self, sample, filenameformat, isneutron, qmax, dq, startx, finishx, lattice, path=os.getcwd(), cycles=30,
                  isrebin=False, bin="0.02", lor=0, alpha=0, filename="batch_modes_single.inp", refine_angles=False):
        print("Creating input file...")
        self.filename = filename
        self.sample = sample

        entry = self.instrument_pars(cycles, path, filenameformat, isneutron, qmax, lor, dq, alpha,
                                     startx, finishx, isrebin, rebindx=bin)
        entry += self.phase(bin, lattice, refine_angles)
        entry += self.modes_single()

        entry += self.output_single(sample)
        f = open(filename, "w")
        f.write(entry)
        f.close()
        self.meta = f"Run {sample} was executed with a fitting range of {startx}-{finishx} angstrom, with {cycles} cycles per irrep. Instrumental values of qmax = {qmax}, dq = {dq}, lor = {lor} and alpha = {alpha}."
        print("...%s written" % filename)


    def create_hdf5_single(self,temps, unique = True, skip_irreps = [], index=[]):
        #does not store norms, mode amplitudes

        if not hasattr(self, "sample"):
            self.sample = input("Enter sample name to create hdf file for: ")

        if not hasattr(self, "meta"):
            self.meta = input("Enter some information to store to remind you of parameters used in this sapa run: ")

        hdf = h5py.File(f"{self.sample}_singlemode.hdf5","w")
        hdf.attrs["metadata"] = self.meta
        if index:
            tempsf = [float(x) for x in index]
        else:
            tempsf = [float(x) for x in temps]
        temp_arr = np.asarray(tempsf)
        hdf["temps"] = temp_arr
        irreps = self.irrep_list()
        if skip_irreps:
            irreps = [x for x in irreps if x not in skip_irreps]

        hdf.attrs["irreps"] = irreps
        df_calc = pd.read_csv(f"mode0_{self.sample}_singlemode_nomodes_{temps[0]}_ycalc.txt", sep=r"\s+", index_col=None,
                              names=["x", "ycalc"])

        hdf.create_dataset("r_vals", data = np.asarray(df_calc["x"]))

        grp = hdf.create_group("nomodes")
        grp.create_dataset("ycalc", (len(temps), len(df_calc["ycalc"])))
        grp.create_dataset("yobs", (len(temps), len(df_calc["ycalc"])))
        for i in range(len(temps)):

            temp = temps[i]
            df_c = pd.read_csv(f"mode0_{self.sample}_singlemode_nomodes_{temp}_ycalc.txt", sep=r"\s+", index_col=None,
                               names=["x", "ycalc"], header=None)
            df_o = pd.read_csv(f"mode0_{self.sample}_singlemode_nomodes_{temp}_yobs.txt", sep=r"\s+", index_col=None,
                               names=["x", "yobs"], header=None)
            dset = grp["ycalc"]
            dset[i, :] = np.asarray(df_c["ycalc"])
            dset = grp["yobs"]
            dset[i, :] = np.asarray(df_o["yobs"])


        for irrep in irreps:
            if unique:
                modes = self.unique_modes(irrep)
            else:
                modes = self.get_indices(irrep)
                modes = [x+1 for x in modes]
            for mode in modes:
                grp = hdf.create_group(f"{irrep}/mode{mode}")
                dfn = pd.read_csv(f"mode{mode}_{irrep}_{self.sample}_singlemode_{temps[0]}_out.txt",sep=r"\s+",index_col=None)
                dfn = dfn.drop([0])
                num_cycles = len(dfn["Rwp"])
                dfn = dfn.drop(["Cycle", "Iter"], axis=1)
                prms = dfn.columns
                for prm in prms:
                    grp.create_dataset(prm, (len(temps), num_cycles))
                    hdf[f"{irrep}/mode{mode}/{prm}"].dims[0].label = "Temps"
                grp.create_dataset("delrwp", (len(temps), num_cycles))
                grp.create_dataset("ycalc", (len(temps), len(df_calc["ycalc"])))
                grp.create_dataset("yobs", (len(temps), len(df_calc["ycalc"])))



                for i in range(len(temps)):
                    temp = temps[i]


                    fn = f"mode{mode}_{irrep}_{self.sample}_singlemode_{temp}_out.txt"
                    df = pd.read_csv(fn,sep=r"\s+",index_col=None)
                    df = df.drop([0])
                    df = df.sort_values("Rwp")
                    df.index = range(len(df.index))
                    df = df.drop(["Cycle", "Iter"], axis = 1)
                    names = df.columns
                    for name in names:
                        data = np.asarray(df[name])
                        #print(name, temp,data.shape)
                        dset = grp[name]
                        dset[i,0:len(data)] = data

                    nmdf = pd.read_csv(f"mode0_nomodes_{self.sample}_singlemode_{temp}_out.txt",sep=r"\s+",index_col=None)
                    nmdf = nmdf.drop([0])
                    nmdf = nmdf.sort_values("Rwp")
                    nmdf.index = range(len(nmdf.index))
                    nm_rwp = nmdf.at[0, "Rwp"]

                    rwp = np.asarray(df["Rwp"])
                    delrwp = rwp - nm_rwp
                    dset = grp["delrwp"]
                    dset[i,0:len(delrwp)] = delrwp


                for i in range(len(temps)):
                    temp = temps[i]
                    
                
                    df_c = pd.read_csv(f"mode{mode}_{self.sample}_singlemode_{irrep}_{temp}_ycalc.txt", sep=r"\s+", index_col=None,
                                          names=["x", "ycalc"], header=None)
                    df_o = pd.read_csv(f"mode{mode}_{self.sample}_singlemode_{irrep}_{temp}_yobs.txt", sep=r"\s+", index_col=None,
                                          names=["x", "yobs"], header=None)
                    dset = grp["ycalc"]
                    dset[i,:] = np.asarray(df_c["ycalc"])
                    dset = grp["yobs"]
                    dset[i,:] = np.asarray(df_o["yobs"])

        self.temps = temps
        hdf.close()

    def cleanup_single(self, unique = True, create_zip=True, skip_irreps=[]):

        if not hasattr(self, "sample"):
            self.sample = input("Enter sample name to clean up: ")

        if not hasattr(self, "temps"):
            self.temps = input(f"Enter comma-separated temps for sample {self.sample}: ")
            self.temps = self.temps.split(",")

        irreps = self.irrep_list()
        irreps.append("nomodes")
        if skip_irreps:
            irreps = [x for x in irreps if x not in skip_irreps]












        if create_zip:
            print("Creating zip file...")
            zipObj = ZipFile(f"{self.sample}.zip", "w")

            for irrep in irreps:
                if irrep == "nomodes":
                    modes = [0]
                if unique and irrep != "nomodes":
                    modes = self.unique_modes(irrep)

                elif not unique and irrep != "nomodes":
                    modes = self.get_indices(irrep)
                    modes = [x + 1 for x in modes]

                for mode in modes:
                    for temp in self.temps:
                        zipObj.write(f"mode{mode}_{irrep}_{self.sample}_singlemode_{temp}_out.txt")
                        zipObj.write(f"mode{mode}_{self.sample}_singlemode_{irrep}_{temp}_ycalc.txt")
                        zipObj.write(f"mode{mode}_{self.sample}_singlemode_{irrep}_{temp}_yobs.txt")
            zipObj.close()
            print("...Zip file written.")

        print("Deleting .txt files...")
        for irrep in irreps:

            if irrep == "nomodes":
                modes = [0]
            if unique and irrep != "nomodes":
                modes = self.unique_modes(irrep)

            elif not unique and irrep != "nomodes":
                modes = self.get_indices(irrep)
                modes = [x + 1 for x in modes]
            for mode in modes:
                for temp in self.temps:
                    os.remove(f"mode{mode}_{irrep}_{self.sample}_singlemode_{temp}_out.txt")
                    os.remove(f"mode{mode}_{self.sample}_singlemode_{irrep}_{temp}_ycalc.txt")
                    os.remove(f"mode{mode}_{self.sample}_singlemode_{irrep}_{temp}_yobs.txt")
        print("...Clean up complete.")

    def execute_old(self, temps, verbose=False, skip_irreps = []):
        self.temps = temps
        print("Finding Topas executables...")
        for root, dirs, files in os.walk("C:\\", topdown=False):
            for name in files:
                if name == "tc.exe":
                    topaspath = os.path.join(root, name)
                    dirs[:] = []
                    break
        if not hasattr(self, "filename"):
            self.filename = input("Enter filename: ")
            if self.filename.endswith(".inp") == False:
                self.filename += ".inp"

        if not hasattr(self, "sample"):
            self.sample = input("Enter sample name for this run: ")

        irreps = self.irrep_list()
        irreps.append("nomodes")
        if skip_irreps:
            irreps = [x for x in irreps if x not in skip_irreps]

        inppath = os.path.join(self.wd, self.filename)

        print("Creating Monitoring File...")
        f = open("%s_monitor.txt" % self.sample, "w")
        f.write("Temp   Irrep   Executed \n")
        for temp in temps:
            for irrep in irreps:
                f.write("{0} {1}  False \n".format(temp, irrep))
        f.close()
        f = open("%s_monitor.txt" % self.sample, "r")
        lines = f.readlines()
        f.close()
        print("Executing...")
        totaltime = 0
        for i in range(1, len(lines)):
            args = lines[i].split()
            temp = args[0]
            irrep = args[1]
            start = time.time()
            print("Executing irrep %s for temp %s" % (irrep, temp))
            if verbose == False:
                os.system(
                    topaspath + " " + "\"" + inppath + "\"" + "   \" macro IRREP {{{0}}} macro VAR {{{1}}} #define {0} \" > NUL ".format(
                        irrep, temp))
            else:
                os.system(
                    topaspath + " " + "\"" + inppath + "\"" + "   \" macro IRREP {{{0}}} macro VAR {{{1}}} #define {0} \" ".format(irrep,
                                                                                                                 temp))
            lines[i] = "{0}  {1}  True \n".format(temp, irrep)
            with open("%s_monitor.txt" % self.sample, "w") as file:
                file.writelines(lines)
            end = time.time()
            processtime = end - start
            totaltime += processtime
            averagetime = totaltime / float(i)
            remainingtime = (averagetime * (len(lines) - i - 1)) / 3600
            print("Completed irrep {0} for temp {1}. Process took {2}s ({3} minutes)".format(irrep, temp, processtime,
                                                                                             processtime / 60))
            print("Estimated {0} hours to completion.".format(remainingtime))

    def write_inp_occ(self, sample, filenameformat, isneutron, qmax, dq, startx, finishx, lattice, path=os.getcwd(),
                  cycles=300,
                  isrebin=False, bin="0.02", lor=0, alpha=0, soperlorch=0, filename="batch_modes.inp",
                  refine_angles=False, version="7", singlemode=False):
        print("Creating input file...")
        self.filename = filename
        self.sample = sample

        entry = self.instrument_pars(cycles, path, filenameformat, isneutron, qmax, lor, dq, alpha,
                                     startx, finishx, isrebin, soperlorch=soperlorch, rebindx=bin, version=version)
        entry += self.phase(bin, lattice, refine_angles)
        if singlemode:
            entry += self.modes_single()
            entry += self.output_single(sample)
        else:
            entry += self.modes_occ()
            entry += self.output(sample)
        f = open(filename, "w")
        f.write(entry)
        f.close()
        self.meta = f"Run {sample} was executed with a fitting range of {startx}-{finishx} angstrom, with {cycles} cycles per irrep. Instrumental values of qmax = {qmax}, dq = {dq}, lor = {lor}, soperlorch = {soperlorch} and alpha = {alpha}."
        print("...%s written" % filename)

    def modes_occ(self):
        irreps = self.irrep_list()
        entry = "\'{{{====== MODE DEFINITIONS ===== \n"
        # creating the #ifdef and #ifndef blocks for each irrep
        # position in iso_label list of each irrep corresponds to position in transformation matrix
        # prm name is a{column}

        iso_label = self.iso_occupancymode_label
        for irrep in irreps:
            entry += "'{{{" + f"==={irrep}=== \n"
            entry += "#ifndef %s \n" % irrep
            for i in range(len(iso_label)):
                m = re.search("\](.+?)\(", iso_label[i])
                if m:
                    label = m.group(1)
                    if irrep == label:
                        entry += "prm !a%s 0.00000 min -0.1 max 0.1 val_on_continue = Rand(-0.05,0.05); \' %s \n" % (
                        i + 1, iso_label[i])
            entry += "#endif \n"
            entry += "#ifdef %s \n" % irrep
            mode_labels = []
            mode_nums = []
            for i in range(len(iso_label)):
                m = re.search("\](.+?)\(", iso_label[i])
                if m:
                    label = m.group(1)
                    if irrep == label:
                        mode_labels.append(iso_label[i])
                        mode_nums.append(i+1)
                        #entry += "prm a%s 0.00000 min -0.1 max 0.1 val_on_continue = Rand(-0.05,0.05); \' %s \n" % (
                        #i + 1, iso_label[i])
            mode_chars = [x.split('occ]')[1] for x in mode_labels]
            mode_chars = set(mode_chars)
            for char in mode_chars:
                charp = char.replace('(','')
                charp = charp.replace(')','')
                if irrep.endswith('+'):
                    irr = irrep.replace('+','')
                elif irrep.endswith('-'):
                    irr = irrep.replace('-','')

                entry += f"prm {charp}_{irr} 0.0000 min -1 max 1 val_on_continue = Rand(-0.05,0.05); \n"
                n = 1
                for i in range(len(mode_labels)):

                    if mode_labels[i].endswith(char) and n==1:
                        entry += f'prm a{mode_nums[i]} ={charp}_{irr}; \' {mode_labels[i]} \n'
                        n += 1
                    elif mode_labels[i].endswith(char) and n==2:
                        entry += f'prm a{mode_nums[i]} =-1*{charp}_{irr}; \' {mode_labels[i]} \n'






            entry += "#endif \n"
            entry += "'}}} \n"
        entry += "'}}}"
        entry += "\n \n \n \n"
        entry += "\'{{{===== MODE TO DELTAS TRANSFORMATION ===== \n"
        # write the matrix transformation
        # for each deltacoordinate, e.g. site1_dx, the script finds the non-zero columns and converts to parameter names
        # deltacoord_j = sum_i(dmval_ij*a_i)
        dm_rows = self.iso_occupancymodematrix_row
        dm_cols = self.iso_occupancymodematrix_col
        dm_vals = self.iso_occupancymodematrix_value
        dc_labels = self.iso_deltaoccupancy_label

        for i in range(len(dc_labels)):
            dc_cols = []
            dc_vals = []
            entry += "prm %s =" % dc_labels[i]
            for j in range(len(dm_rows)):

                if int(dm_rows[j]) == i + 1:
                    dc_cols.append(dm_cols[j])
                    dc_vals.append(dm_vals[j])

            for j in range(len(dc_cols)):
                if j == len(dc_cols) - 1:
                    if float(dc_vals[j]) > 0:
                        entry += " + %s*a%s ;: 0.0 \n" % (dc_vals[j], dc_cols[j])
                    else:
                        entry += " %s*a%s ;: 0.0\n" % (dc_vals[j], dc_cols[j])
                else:
                    if float(dc_vals[j]) > 0:
                        entry += " + %s*a%s " % (dc_vals[j], dc_cols[j])
                    else:
                        entry += " %s*a%s " % (dc_vals[j], dc_cols[j])
        entry += "'}}}"
        entry += "\n"
        entry += "'{{{ ===Site Definitions==="
        # define site coordinates, e.g. site_distorted_x = site_x + site_dx
        icl = self.iso_occupancy_label
        print(len(icl))
        #icf = self.iso_coordinate_formula
        entry += "\n"
        xs = self.atom_site_occupancy

        formula = []
        for i in range(len(xs)):
            formula.append(xs[i])

        print(len(formula))
        for i in range(len(icl)):
            # formula = icf[i].strip("\"")
            entry += "prm %s = %s + %s;\n" % (icl[i], xs[i], dc_labels[i])

        entry += "\n"
        #get list of elements involved - this is used for beq function
        atoms = self.atom_site_type_symbol
        elements = set(atoms)
        elements = list(elements)
        elements = [x.strip("+-123456789") for x in elements]
        beq_vars = []
        for i in elements:
            bv = i + "_beq"
            beq_vars.append(bv)
        for i in beq_vars:
            entry += "prm %s 0.01 min 0 max 1 val_on_continue = Rand(0,0.1); \n" % i
        entry += "prm rv 0.01 min 0 val_on_continue = Rand(0,0.1); \n"
        entry += "prm r2v 0.01 min 0 val_on_continue = Rand(0,0.1); \n"
        entry += "prm phase_scale 1 \n"
        sites = self.atom_site_label
        occs = self.atom_site_occupancy
        for i in range(len(sites)):
            entry += "site %s " % sites[i]
            entry += " x = %s; " % self.atom_site_fract_x[i]
            entry += " y = %s; " % self.atom_site_fract_y[i]
            entry += " z = %s; " % self.atom_site_fract_z[i]
            entry += " occ %s = %s;" % (atoms[i].strip("+-123456789"), icl[i])
            for j in range(len(elements)):
                if atoms[i].strip("+-123456789") == elements[j]:
                    bn = "beq_" + str(i)
                    entry += "beq_r_r2(%s,=%s;,d1,=rv;,d2,=r2v;) \n" % (bn, beq_vars[j])
        entry += "scale = phase_scale; \n"
        entry += "'}}} \n"
        return entry

    def create_hdf5_occ(self, temps, skip_irreps=[]):

        if not hasattr(self, "sample"):
            self.sample = input("Enter sample name to create hdf file for: ")

        if not hasattr(self, "meta"):
            self.meta = input("Enter some information to store to remind you of parameters used in this sapa run: ")

        hdf = h5py.File(f"{self.sample}.hdf5", "w")
        hdf.attrs["metadata"] = self.meta
        tempsf = [float(x) for x in temps]
        temp_arr = np.asarray(tempsf)
        hdf["temps"] = temp_arr
        irreps = self.irrep_list()
        if skip_irreps:
            irreps = [x for x in irreps if x not in skip_irreps]

        hdf.attrs["irreps"] = irreps
        df_calc = pd.read_csv(f"{self.sample}_{irreps[0]}_{temps[0]}_ycalc.txt", sep=r"\s+", index_col=None,
                              names=["x", "ycalc"])

        hdf.create_dataset("r_vals", data=np.asarray(df_calc["x"]))

        grp = hdf.create_group("nomodes")
        grp.create_dataset("ycalc", (len(temps), len(df_calc["ycalc"])))
        grp.create_dataset("yobs", (len(temps), len(df_calc["ycalc"])))
        for i in range(len(temps)):

            temp = temps[i]
            df_c = pd.read_csv(f"{self.sample}_nomodes_{temp}_ycalc.txt", sep=r"\s+", index_col=None,
                               names=["x", "ycalc"], header=None)
            df_o = pd.read_csv(f"{self.sample}_nomodes_{temp}_yobs.txt", sep=r"\s+", index_col=None,
                               names=["x", "yobs"], header=None)
            dset = grp["ycalc"]
            dset[i, :] = np.asarray(df_c["ycalc"])
            dset = grp["yobs"]
            dset[i, :] = np.asarray(df_o["yobs"])

        for irrep in irreps:
            grp = hdf.create_group(f"{irrep}")
            dfn = pd.read_csv(f"{irrep}_{self.sample}_{temps[0]}_out.txt", sep=r"\s+", index_col=None)
            dfn = dfn.drop([0])
            num_cycles = len(dfn["Rwp"])
            dfn = dfn.drop(["Cycle", "Iter"], axis=1)
            prms = dfn.columns
            for prm in prms:
                grp.create_dataset(prm, (len(temps), num_cycles))
                hdf[f"{irrep}/{prm}"].dims[0].label = "Temps"
            grp.create_dataset("delrwp", (len(temps), num_cycles))

            # print(irrep, norms)


            grp.create_dataset("ycalc", (len(temps), len(df_calc["ycalc"])))
            grp.create_dataset("yobs", (len(temps), len(df_calc["ycalc"])))

            for i in range(len(temps)):
                temp = temps[i]
                fn = f"{irrep}_{self.sample}_{temp}_out.txt"
                df = pd.read_csv(fn, sep=r"\s+", index_col=None)
                df = df.drop([0])
                df = df.sort_values("Rwp")
                df.index = range(len(df.index))
                df = df.drop(["Cycle", "Iter"], axis=1)
                names = df.columns
                for name in names:
                    data = np.asarray(df[name])
                    # print(name, temp,data.shape)
                    dset = grp[name]
                    dset[i, 0:len(data)] = data

                nmdf = pd.read_csv(f"nomodes_{self.sample}_{temp}_out.txt", sep=r"\s+", index_col=None)
                nmdf = nmdf.drop([0])
                nmdf = nmdf.sort_values("Rwp")
                nmdf.index = range(len(nmdf.index))
                nm_rwp = nmdf.at[0, "Rwp"]

                rwp = np.asarray(df["Rwp"])
                delrwp = rwp - nm_rwp
                dset = grp["delrwp"]
                dset[i, 0:len(delrwp)] = delrwp



            for i in range(len(temps)):
                temp = temps[i]
                df_c = pd.read_csv(f"{self.sample}_{irrep}_{temp}_ycalc.txt", sep=r"\s+", index_col=None,
                                   names=["x", "ycalc"], header=None)
                df_o = pd.read_csv(f"{self.sample}_{irrep}_{temp}_yobs.txt", sep=r"\s+", index_col=None,
                                   names=["x", "yobs"], header=None)
                dset = grp["ycalc"]
                dset[i, :] = np.asarray(df_c["ycalc"])
                dset = grp["yobs"]
                dset[i, :] = np.asarray(df_o["yobs"])

        self.temps = temps
        hdf.close()

    def import_amps(self):
        if not hasattr(self, "filename"):
            self.filename = input("Enter filename: ")
        if self.filename.endswith(".inp") == False:
            self.filename += ".inp"

        inp = open(self.filename, 'r')
        inp_lines = inp.readlines()
        inp.close()

        for i in range(len(self.iso_displacivemode_value)):
            if float(self.iso_displacivemode_value[i]) != 0.0:
                print('writing mode')
                mode_n = i+1
                norm = self.iso_displacivemodenorm_value[i]
                iso_label = self.iso_displacivemode_label[i]
                mode_val = float(self.iso_displacivemode_value[i])
                for j in range(len(inp_lines)):
                    if inp_lines[j].startswith(f'prm a{mode_n}'):
                        inp_lines[j] = f"prm a{i + 1} {mode_val} min -{(0.1 / float(norm))+mode_val} max {(0.1 / float(norm))+mode_val} val_on_continue = Rand({mode_val+(-0.05 / float(norm))},{mode_val+(0.05 / float(norm))}); \' {iso_label} \n"
                    elif inp_lines[j].startswith(f'prm !a{mode_n}'):
                        inp_lines[j] = f"prm !a{i + 1} {mode_val} min -{(0.1 / float(norm)) + mode_val} max {(0.1 / float(norm)) + mode_val} val_on_continue = Rand({mode_val + (-0.05 / float(norm))},{mode_val + (0.05 / float(norm))}); \' {iso_label} \n"

        with open(self.filename, 'w') as f:
            for line in inp_lines:
                f.write(line)

    def create_hdf5_normalise(self, temps, skip_irreps=[],index=[]):

        if not hasattr(self, "sample"):
            self.sample = input("Enter sample name to create hdf file for: ")


        if not hasattr(self, "meta"):
            self.meta = input("Enter some information to store to remind you of parameters used in this sapa run: ")

        hdf = h5py.File(f"{self.sample}.hdf5","w")
        hdf.attrs["metadata"] = self.meta
        if index:
            tempsf = [float(x) for x in index]
        else:
            tempsf = [float(x) for x in temps]
        temp_arr = np.asarray(tempsf)
        hdf["temps"] = temp_arr
        irreps = self.irrep_list()
        if skip_irreps:
            irreps = [x for x in irreps if x not in skip_irreps]

        hdf.attrs["irreps"] = irreps
        df_calc = pd.read_csv(f"{self.sample}_{irreps[0]}_{temps[0]}_ycalc.txt", sep=r"\s+", index_col=None,
                              names=["x", "ycalc"])

        hdf.create_dataset("r_vals", data = np.asarray(df_calc["x"]))

        grp = hdf.create_group("nomodes")
        grp.create_dataset("ycalc", (len(temps), len(df_calc["ycalc"])))
        grp.create_dataset("yobs", (len(temps), len(df_calc["ycalc"])))
        for i in range(len(temps)):

            temp = temps[i]
            df_c = pd.read_csv(f"{self.sample}_nomodes_{temp}_ycalc.txt", sep=r"\s+", index_col=None,
                               names=["x", "ycalc"], header=None)
            df_o = pd.read_csv(f"{self.sample}_nomodes_{temp}_yobs.txt", sep=r"\s+", index_col=None,
                               names=["x", "yobs"], header=None)
            dset = grp["ycalc"]
            dset[i, :] = np.asarray(df_c["ycalc"])
            dset = grp["yobs"]
            dset[i, :] = np.asarray(df_o["yobs"])


        for irrep in irreps:
            grp = hdf.create_group(f"{irrep}")
            dfn = pd.read_csv(f"{irrep}_{self.sample}_{temps[0]}_out.txt",sep=r"\s+",index_col=None)
            dfn = dfn.drop([0])
            num_cycles = len(dfn["Rwp"])
            dfn = dfn.drop(["Cycle", "Iter"], axis=1)
            prms = dfn.columns
            for prm in prms:
                grp.create_dataset(prm, (len(temps), num_cycles))
                hdf[f"{irrep}/{prm}"].dims[0].label = "Temps"
            grp.create_dataset("delrwp", (len(temps), num_cycles))
            if hasattr(self, "iso_displacivemodenorm_value") and not hasattr(self, "iso_occupancymodenorm_value"):
                regex = re.compile(r"^a[0-9]+")
                mode_prms = [x for x in prms if regex.search(x)]


            elif hasattr(self, "iso_occupancymodenorm_value") and not hasattr(self, "iso_displacivemodenorm_value"):
                regex = re.compile(r"^b[0-9]+")
                mode_prms = [x for x in prms if regex.search(x)]



            #print(irrep, norms)

            grp.create_dataset("mode_amps", (len(temps), num_cycles))
            grp.create_dataset("ycalc", (len(temps), len(df_calc["ycalc"])))
            grp.create_dataset("yobs", (len(temps), len(df_calc["ycalc"])))



            for i in range(len(temps)):
                temp = temps[i]
                fn = f"{irrep}_{self.sample}_{temp}_out.txt"
                df = pd.read_csv(fn,sep=r"\s+",index_col=None)
                df = df.drop([0])
                df = df.sort_values("Rwp")
                df.index = range(len(df.index))
                df = df.drop(["Cycle", "Iter"], axis = 1)
                names = df.columns
                for name in names:
                    data = np.asarray(df[name])
                    #print(name, temp,data.shape)
                    dset = grp[name]
                    dset[i,0:len(data)] = data

                nmdf = pd.read_csv(f"nomodes_{self.sample}_{temp}_out.txt",sep=r"\s+",index_col=None)
                nmdf = nmdf.drop([0])
                nmdf = nmdf.sort_values("Rwp")
                nmdf.index = range(len(nmdf.index))
                nm_rwp = nmdf.at[0, "Rwp"]

                rwp = np.asarray(df["Rwp"])
                delrwp = rwp - nm_rwp
                dset = grp["delrwp"]
                dset[i,0:len(delrwp)] = delrwp

            for i in range(len(temps)):
                temp = temps[i]
                fn = f"{irrep}_{self.sample}_{temp}_out.txt"
                df = pd.read_csv(fn, sep=r"\s+", index_col=None)
                df = df.drop([0])
                df = df.sort_values("Rwp")
                df.index = range(len(df.index))
                df["mode_amps"] = (df[mode_prms[0]]) ** 2
                for j in range(1, len(mode_prms)):
                    df["mode_amps"] += (df[mode_prms[j]]) ** 2
                df["mode_amps"] = np.sqrt(df["mode_amps"])
                dset = grp["mode_amps"]
                ma_data = np.asarray(df["mode_amps"])
                dset[i,0:len(ma_data)] = ma_data


            for i in range(len(temps)):
                temp = temps[i]
                df_c = pd.read_csv(f"{self.sample}_{irrep}_{temp}_ycalc.txt", sep=r"\s+", index_col=None,
                                      names=["x", "ycalc"], header=None)
                df_o = pd.read_csv(f"{self.sample}_{irrep}_{temp}_yobs.txt", sep=r"\s+", index_col=None,
                                      names=["x", "yobs"], header=None)
                dset = grp["ycalc"]
                dset[i,:] = np.asarray(df_c["ycalc"])
                dset = grp["yobs"]
                dset[i,:] = np.asarray(df_o["yobs"])

        self.temps = temps
        hdf.close()

    def create_hdf5(self, temps, singlemode=False, occupancy=False, normalise=True, unique=True, skip_irreps=[],index=[]):
        if normalise:
            self.create_hdf5_normalise(temps, skip_irreps,index=index)
        elif singlemode:
            self.create_hdf5_single(temps, unique, skip_irreps,index=index)
        elif occupancy:
            self.create_hdf5_occ(temps, skip_irreps)
        else:
            self.create_hdf5_base(temps, skip_irreps,index=index)













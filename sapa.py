import numpy as np
import pandas as pd
import re
import os
import shutil as sh
import glob
import time
import difflib as dl


# the class which can contain any cif file
# IMPORTANT - the cif file must have a line at the end starting with a # symbol
# This is included by default in cifs generated by ISODISTORT
# This is NOT included by default in cifs generated by TOPAS
class sapa:
    """A class used to generate and execute symmetry-adapted PDF analysis (SAPA) input files for TOPAS

    ...

    Arguments
    ----------
    cif_file : The sapa class takes an ISODISTORT-generated cif as it's only input. The filename is required to be a string
    and must have a line designating the end of the file (e.g. #End)

    sample : A sample name used for reference. It is used in output file names. Format - string

    cycles : The number of convergences to be performed for each irreducible representation (irrep). Format - string

    path : The path to the directory containing the data files. Do not include any filename in this argument. Use double
           slashes e.g. C:\\Data\\PDF_files\\ - do not use directories containing spaces - Format - string

    filenameformat : The format of the data file name. The data files should be named in a way to allow them to be cycle
                    over easily, e.g. if you have neutron PDF data for Barium Titanate at 150 K, 200 K, 250 K etc., they
                    should be named something like BaTiO3_NPDF_125K.xye . To allow cycling, the filenameformat is then
                    BaTiO3_NPDF_##n##K.xye - Format : string

    isneutron : Set this to True if your data is neutron data - Format : Boolean

    qmax : The maximum Q value used when generating the PDFs. If this value is not constant, please see examples for
        cycling through additional variables. Format - string

    islor : Set this to true if you are using Lorentzian damping. See "TOPAS Instrumental Functions for PDF Data" at
            https://www.diamond.ac.uk/Instruments/Crystallography/I15-1/Staff/Philip-Chater.html for more info
            Format - Boolean

    lor : Lorentzian damping value. Format - string

    dq : The dQ value for the PDFs, typically refined using a standard. Format - string

    isalpha : Set this to true if the alpha parameter for Q-dependent peak broadening is used. NOTE : this
              significantly slows down refinements. Format - Boolean

    alpha : Alpha value for Q-dependent peak broadening. Format - string

    isrebin : Set to true if you want to rebin your data. Format - Boolean

    bin : Data bin size. This is important, as Topas and Gudrun define bins differently, so an correction is
          made in the input file. Format - string

    startx : Radius to start refinements at. Due to the convolution with a sinc function, it is not recommended
            to reduce this below 1.0. Format - string

    finishx : Upper value for fitting data. Data is only fitted for radii between startx -> finishx
              Format - string

    filename : name of input file for writing and execution. The default is batch_modes.inp - note the extension is
                required. Format - string

    lattice : Defines the restraints on lattice parameters. Permitted values are "C", "T" or "O"
                For "C", all lattice parameters are restricted to be equal
                For "T", a and b are given the value for cell_length_a and restricted to be equal.
                For "O", a, b and c refine freely.

    topaspath : The path that contains the topas executables. Format - string

    temps : A list of temperatures or other variable to iterate over. The elements in this list replace the ##n##
            in the filenameformat argument. Format - list of strings



    Methods
    -------
    sapa(cif_file) : imports the ISODISTORT cif file - this is the main function of the class

    write_inp(sample,cycles,path,filenameformat,isneutron,qmax,islor,dq,isalpha,startx,finishx,
            isrebin,bin="0.02",lor="0.0",alpha="0.0",filename="batch_modes.inp") : generates a topas input file for
            SAPA

    execute(filename,topaspath,temps) : executes the topas input file. Output files are generated with the format
        IRREP_sample_TEMP_out.txt for each irrep and temperature. These can be interacted with using the sapa_utils
        class

    irrep_list() : writes a list of the irreps defined in the ISODISTORT CIF

    Variables
    ---------

    Any variables defined in the CIF can be accessed as a class variable. These are strings, for isolated values, or
    lists of strings, for any variable defined within a loop_ in the CIF.  For example:
    C:\working_dir\> import sapa as s
    C:\working_dir\> struc = s.sapa("batio3_iso.cif")
    C:\working_dir\> print(struc.iso_displacivemode_label) -> this line prints the iso_displacivemode_label list
    """

    def __init__(self, cif_file):

        self.wd = os.getcwd()
        f = open(cif_file, "r")
        lines = f.readlines()
        count = 0
        count_cifloop = 0
        for n in range(0, len(lines)):
            line = lines[n]
            # reads single value entry in cif file and creats a class attribute with value stored as str
            if line[0] == "_" and len(line.split()) == 2:
                vars(self)['%s' % (line.split()[0].lstrip(
                    "_").strip())] = line.split()[1]

            # reads single line entries in cif file where data is on the next line
            # if line[0] == "_" and len(line.split())==1 and r'[\t]' not in line and lines[n+1][0] != '_':
            #   vars(self)['%s'%(line.lstrip("_").rstrip("\n").strip())] = lines[n+1].strip().sub(r'[\t]', '').rstrip("\n")

            # reads multiline entries in table format....
            if line[0:5] == "loop_":
                n = n + 1
                m = 0
                while "_" in lines[n + m][0]:
                    vars(self)['%s' %
                               (lines[n + m].lstrip("_").rstrip("\n"))] = []
                    m = m + 1
                    # work out out many columns the mutiline entreis have....
                q = 0
                while len(lines[n + m + q]) > 2 and "loop_" not in lines[n + m + q] and "#" not in lines[n + m + q]:
                    k = 0

                    for k in range(m):
                        # each multiline becomesa. a attribute of the class with the associated value set.
                        try:
                            vars(self)['%s' % (
                                lines[n + k].lstrip("_").rstrip("\n").strip())].append(lines[n + m + q].split()[k])
                        except:
                            print("cif file error in %s at line %d" %
                                  (cif_file, n))
                    q = q + 1
                    count_cifloop = q + m

            # interate forwards so that I don't re-read the cif.
            n = n + count_cifloop

        f.close()

    # converts any matricies in cif loop format in matrix foramt
    def make_matrices(self):
        for class_attribute in dir(self):
            if "_row" in class_attribute:
                rows = np.array(vars(self)['%s' %
                                           class_attribute]).astype(np.int)
                cols = np.array(vars(self)['%s_col' %
                                           class_attribute[:-4]]).astype(np.int)
                values = vars(self)['%s_value' % class_attribute[:-4]]
                cif_loop_matrix = np.zeros([max(rows), max(cols)])
                # print rows
                # print cols
                for val_index in range(len(values)):
                    cif_loop_matrix[rows[val_index] - 1,
                                    cols[val_index] - 1] = values[val_index]

                vars(self)['%s_matrix' % class_attribute[:-4]
                           ] = np.matrix(cif_loop_matrix)

    # takes mode matrix
    def constraint_array(self, mode_number):
        mode_matrix = self.iso_displacivemodematrix_matrix
        if (len(mode_matrix[:, 0]) >= mode_number) and (mode_number > 0):
            vector = np.zeros([len(mode_matrix[:, 0]), 1])
            vector[mode_number - 1, 0] = 1
            return mode_matrix * vector

        else:
            print("mode number is outside range")
            return 0

        # split constraints up into x, y and z array.

    def make_x_y_z_constrains(self, c_array):
        # make x, y, z array
        xyz_label = self.iso_deltacoordinate_label
        c_x = []  # np.zeros[len(xyz_label)/3,1]
        c_y = []  # np.zeros[len(xyz_label)/3,1]
        c_z = []  # np.zeros[len(xyz_label)/3,1]
        for i in range(len(c_array) / 3):
            c_x.append(c_array[i * 3, 0])
            c_y.append(c_array[(i * 3) + 1, 0])
            c_z.append(c_array[(i * 3) + 2, 0])

        return c_x, c_y, c_z

    # method to return constraints all in one step.
    def constraints_out(self, mode_number):
        self.make_matrices()
        c_array = self.constraint_array(mode_number)
        c_x, c_y, c_z = self.make_x_y_z_constrains(c_array)
        # print c_x, c_y, c_z
        return c_x, c_y, c_z


    def irrep_list(self):
        irreps = []
        for i in self.iso_displacivemode_label:
            m = re.search("\](.+?)\(", i)
            if m:
                label = m.group(1)
                irreps.append(label)
        irreps = list(dict.fromkeys(irreps))
        return irreps

    def instrument_pars(self, cycles, path, filenameformat, isneutron, qmax, lor, dq, alpha, startx, finishx, isrebin,
                        rebindx):
        entry = "r_wp 0.0 r_exp 0.0 r_p 0.0 r_wp_dash 0.0 r_exp_dash 0.0 weighted_Durbin_Watson 0.0 gof 0.0 \n"
        entry += "iters 10000000 \n"
        entry += "chi2_convergence_criteria 0.001 \n"
        entry += "continue_after_convergence \n"
        entry += "prm dummy  0.00000` val_on_continue = If(Cycle == {0}, Get(iters) = 0, 0); \n".format(cycles)
        entry += "\n"
        entry += " \' File input macro example. The ##n## is replaced when called. \n"
        entry += "macro file_in_(n) \n"
        if path.endswith("\\") == False:
            entry += "{\n %s\\%s \n" % (path, filenameformat)
        else:
            entry += "{\n %s%s \n" % (path, filenameformat)
        entry += "} \n"
        entry += "xdd file_in_(VAR) \n"
        entry += "   weighting = 1; \n"
        if isneutron == True:
            entry += "   neutron_data \n"
        entry += "pdf_data \n"
        if isrebin == True:
            # entry+= "   rebin_start_x_at 0 \n"
            entry += "   rebin_with_dx_of %s \n" % rebindx
        entry += "start_X {0} \n".format(startx)
        entry += "finish_X {0} \n" .format(finishx)
        if lor != 0:
            entry += " dQ_lor_damping(!dQ,{0},!lor,{1}) \n".format(dq, lor)
        else:
            entry += "   dQ_damping(!dQ,{0}) \n".format(dq)
        entry += "   convolute_Qmax_Sinc(!Qmax,{0}) \n".format(qmax)
        if alpha != 0:
            print("Warning: use of alpha parameter significantly slows down refinements")
            entry += " convolute_alpha(!alpha,{0}) \n".format(alpha)
        return entry

    def phase(self, bin, lattice):
        zero = float(bin) / 2
        zero = str(zero)
        entry = "\'=== PHASE INFORMATION === \n"
        entry += "      str \n"
        entry += "         a lprm_a %s \n" % self.cell_length_a
        if lattice == "C":
            entry += "         b lprm_a %s \n" % self.cell_length_a
            entry += "         c lprm_a %s \n" % self.cell_length_a
        elif lattice == "T":
            entry += "         b lprm_a %s \n" % self.cell_length_a
            entry += "         c lprm_c %s \n" % self.cell_length_c
        elif lattice == "O":
            entry += "         b lprm_b %s \n" % self.cell_length_b
            entry += "         c lprm_c %s \n" % self.cell_length_c
        else:
            print("Unexpected value for lattice argument. Expected C, T or O. Exiting...")
            exit()

        entry += "         al %s \n" % self.cell_angle_alpha
        entry += "         be %s \n" % self.cell_angle_beta
        entry += "         ga %s \n" % self.cell_angle_gamma
        entry += "         volume %s \n" % self.cell_volume
        entry += "         space_group %s \n" % self.symmetry_Int_Tables_number
        entry += "         pdf_zero -%s \n" % zero
        entry += "\n \n \n \n"
        return entry

    def modes(self):
        irreps = self.irrep_list()
        entry = "\'====== MODE DEFINITIONS ===== \n"
        iso_label = self.iso_displacivemode_label
        for irrep in irreps:
            entry += "#ifndef %s \n" % irrep
            for i in range(len(iso_label)):
                m = re.search("\](.+?)\(", iso_label[i])
                if m:
                    label = m.group(1)
                    if irrep == label:
                        entry += "prm !a%s 0.00000 min -1 max 1 val_on_continue = Rand(-0.05,0.05); \' %s \n" % (
                        i + 1, iso_label[i])
            entry += "#endif \n"
            entry += "#ifdef %s \n" % irrep
            for i in range(len(iso_label)):
                m = re.search("\](.+?)\(", iso_label[i])
                if m:
                    label = m.group(1)
                    if irrep == label:
                        entry += "prm a%s 0.00000 min -1 max 1 val_on_continue = Rand(-0.05,0.05); \' %s \n" % (
                        i + 1, iso_label[i])
            entry += "#endif \n"
        entry += "\n \n \n \n"
        entry += "\'===== MODE TO DELTAS TRANSFORMATION ===== \n"
        dm_rows = self.iso_displacivemodematrix_row
        dm_cols = self.iso_displacivemodematrix_col
        dm_vals = self.iso_displacivemodematrix_value
        dc_labels = self.iso_deltacoordinate_label

        for i in range(len(dc_labels)):
            dc_cols = []
            dc_vals = []
            entry += "prm %s =" % dc_labels[i]
            for j in range(len(dm_rows)):

                if int(dm_rows[j]) == i + 1:
                    dc_cols.append(dm_cols[j])
                    dc_vals.append(dm_vals[j])

            for j in range(len(dc_cols)):
                if j == len(dc_cols) - 1:
                    if float(dc_vals[j]) > 0:
                        entry += " + %s*a%s ;: 0.0 \n" % (dc_vals[j], dc_cols[j])
                    else:
                        entry += " %s*a%s ;: 0.0\n" % (dc_vals[j], dc_cols[j])
                else:
                    if float(dc_vals[j]) > 0:
                        entry += " + %s*a%s " % (dc_vals[j], dc_cols[j])
                    else:
                        entry += " %s*a%s " % (dc_vals[j], dc_cols[j])
        icl = self.iso_coordinate_label
        print(len(icl))
        icf = self.iso_coordinate_formula
        entry += "\n"
        xs = self.atom_site_fract_x
        ys = self.atom_site_fract_y
        zs = self.atom_site_fract_z
        formula = []
        for i in range(len(xs)):
            formula.append(xs[i])
            formula.append(ys[i])
            formula.append(zs[i])
        print(len(formula))
        for i in range(len(icl)):
            # formula = icf[i].strip("\"")
            entry += "prm %s = %s + %s;\n" % (icl[i], formula[i], dc_labels[i])

        entry += "\n"
        atoms = self.atom_site_type_symbol
        elements = set(atoms)
        elements = list(elements)
        elements = [x.strip("+-123456789") for x in elements]
        beq_vars = []
        for i in elements:
            bv = i + "_beq"
            beq_vars.append(bv)
        for i in beq_vars:
            entry += "prm %s 0.01 min 0 max 1 val_on_continue = Rand(0,0.1); \n" % i
        entry += "prm rv 0.01 min 0 val_on_continue = Rand(0,0.1); \n"
        entry += "prm r2v 0.01 min 0 val_on_continue = Rand(0,0.1); \n"
        entry += "prm phase_scale 1 \n"
        sites = self.atom_site_label
        occs = self.atom_site_occupancy
        for i in range(len(sites)):
            entry += "site %s " % sites[i]
            entry += " x = %s; " % icl[3 * i]
            entry += " y = %s; " % icl[3 * i + 1]
            entry += " z = %s; " % icl[3 * i + 2]
            entry += " occ %s %s " % (atoms[i].strip("+-123456789"), occs[i])
            for j in range(len(elements)):
                if atoms[i].strip("+-123456789") == elements[j]:
                    bn = "beq_" + str(i)
                    entry += "beq_r_r2(%s,=%s;,d1,=rv;,d2,=r2v;) \n" % (bn, beq_vars[j])
        entry += "scale = phase_scale; \n"
        return entry

    def output(self, sample):
        entry = "macro file_out_(m,n) \n { \n m##_%s_##n##_out.txt \n } \n" % sample
        entry += "out_prm_vals_on_convergence file_out_(IRREP,VAR) \n"
        return entry

    def write_inp(self, sample, filenameformat, isneutron, qmax, dq, startx, finishx, lattice, path=os.getcwd(), cycles=300,
                  isrebin=False, bin="0.02", lor=0, alpha=0, filename="batch_modes.inp"):
        print("Creating input file...")
        self.filename = filename
        self.sample = sample

        entry = self.instrument_pars(cycles, path, filenameformat, isneutron, qmax, lor, dq, alpha,
                                     startx, finishx, isrebin, rebindx=bin)
        entry += self.phase(bin, lattice)
        entry += self.modes()

        entry += self.output(sample)
        f = open(filename, "w")
        f.write(entry)
        f.close()
        print("...%s written" % filename)

    def execute(self, temps, verbose=False):
        print("Finding Topas executables...")
        for root, dirs, files in os.walk("C:\\", topdown=False):
            for name in files:
                if name == "tc.exe":
                    topaspath = os.path.join(root, name)
                    dirs[:] = []
                    break
        if not hasattr(self, "filename"):
            self.filename = input("Enter filename: ")
            if self.filename.endswith(".inp") == False:
                self.filename += ".inp"

        if not hasattr(self, "sample"):
            self.sample = input("Enter sample name for this run: ")

        irreps = self.irrep_list()
        irreps.append("nomodes")

        inppath = os.path.join(self.wd, self.filename)

        print("Creating Monitoring File...")
        f = open("%s_monitor.txt" % self.sample, "w")
        f.write("Temp   Irrep   Executed \n")
        for temp in temps:
            for irrep in irreps:
                f.write("{0} {1}  False \n".format(temp, irrep))
        f.close()
        f = open("%s_monitor.txt" % self.sample, "r")
        lines = f.readlines()
        f.close()
        print("Executing...")
        totaltime = 0
        for i in range(1, len(lines)):
            args = lines[i].split()
            temp = args[0]
            irrep = args[1]
            start = time.time()
            print("Executing irrep %s for temp %s" % (irrep, temp))
            if verbose == False:
                os.system(
                    topaspath + " " + inppath + "   \" macro IRREP {{{0}}} macro VAR {{{1}}} #define {0} \" > NUL ".format(
                        irrep, temp))
            else:
                os.system(
                    topaspath + " " + inppath + "   \" macro IRREP {{{0}}} macro VAR {{{1}}} #define {0} \" ".format(irrep,
                                                                                                                 temp))
            lines[i] = "{0}  {1}  True \n".format(temp, irrep)
            with open("%s_monitor.txt" % self.sample, "w") as file:
                file.writelines(lines)
            end = time.time()
            processtime = end - start
            totaltime += processtime
            averagetime = totaltime / float(i)
            remainingtime = (averagetime * (len(lines) - i - 1)) / 3600
            print("Completed irrep {0} for temp {1}. Process took {2}s ({3} minutes)".format(irrep, temp, processtime,
                                                                                             processtime / 60))
            print("Estimated {0} hours to completion.".format(remainingtime))

    def restart(self):
        print("Finding Topas executables...")
        for root, dirs, files in os.walk("C:\\", topdown=False):
            for name in files:
                if name == "tc.exe":
                    topaspath = os.path.join(root, name)
                    dirs[:] = []
                    break

        if not hasattr(self, "filename"):
            self.filename = input("Enter filename: ")
            if self.filename.endswith(".inp") == False:
                self.filename += ".inp"

        if not hasattr(self, "sample"):
            self.sample = input("Enter sample name to restart: ")

        f = open("%s_monitor.txt" % self.sample, "r")
        lines = f.readlines()
        f.close()

        irreps = self.irrep_list()
        irreps.append("nomodes")
        wd = os.getcwd()
        inppath = os.path.join(wd, self.filename)
        totaltime = 0
        print("Restarting...")
        for i in range(1, len(lines)):
            args = lines[i].split()
            temp = args[0]
            irrep = args[1]

            if args[2] == "False":
                start = time.time()
                print("Executing irrep %s for temp %s" % (irrep, temp))
                os.system(topaspath + " " + inppath + "   \" macro IRREP {%s} macro VAR {%s} #define %s \" > NUL" % (
                irrep, temp, irrep))
                lines[i] = "%s  %s  True \n" % (temp, irrep)
                with open("%s_monitor.txt" % self.sample, "w") as file:
                    file.writelines(lines)
                end = time.time()
                processtime = end - start
                totaltime += processtime
                averagetime = totaltime / float(i)
                remainingtime = (averagetime * (len(lines) - i - 1)) / 3600
                print(
                    "Completed irrep {0} for temp {1}. Process took {2}s ({3} minutes)".format(irrep, temp, processtime,
                                                                                               processtime / 60))
                print("Estimated {0} hours to completion.".format(remainingtime))

    def idformat(self, path):
        data = os.listdir(f"./{path}")
        seq = dl.SequenceMatcher(None, data[0], data[1])
        blocks = seq.get_matching_blocks()
        string = data[1]
        start = string[blocks[0][0]:blocks[0][2]]
        end = string[blocks[1][0]:]
        start_lens = []
        end_lens = []
        for i in range(2, len(data)):
            start_diff = dl.SequenceMatcher(None, start, data[i])
            start_blocks = start_diff.get_matching_blocks()
            start_lens.append(start_blocks[0][2])
            end_diff = dl.SequenceMatcher(None, end, data[i])
            end_blocks = end_diff.get_matching_blocks()
            end_lens.append(end_blocks[0][2])
        start_min = min(start_lens)
        end_min = -1 * min(end_lens)
        start_string = string[:start_min]
        end_string = string[end_min:]
        print(start_string, end_string)
        return start_string, end_string
